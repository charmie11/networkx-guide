(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{151:function(t,e,r){"use strict";r.r(e),e.default=r.p+"assets/images/shortest-path-example-510eddb7868bfa24c0ea29f009894d0a.jpg"},87:function(t,e,r){"use strict";r.r(e),r.d(e,"frontMatter",(function(){return s})),r.d(e,"metadata",(function(){return i})),r.d(e,"toc",(function(){return l})),r.d(e,"default",(function(){return c}));var a=r(3),n=r(7),o=(r(0),r(95)),s={id:"shortest-path",title:"Shortest path algorithms",sidebar_label:"Shortest path",slug:"/algorithms/shortest-path"},i={unversionedId:"algorithms/shortest-path/shortest-path",id:"algorithms/shortest-path/shortest-path",isDocsHomePage:!1,title:"Shortest path algorithms",description:"When planning a road trip, we are trying to minimize our costs in many different areas - gas, time, overnight stays, traffic costs, etc. Calculating these costs can take a lot of effort and time, but what if there was a more elegant way that could solve the problem for you?",source:"@site/docs/algorithms/shortest-path/shortest-path.md",slug:"/algorithms/shortest-path",permalink:"/algorithms/shortest-path",editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/algorithms/shortest-path/shortest-path.md",version:"current",sidebar_label:"Shortest path",sidebar:"networkx_guide",previous:{title:"Algorithms overview",permalink:"/algorithms"},next:{title:"Dijkstra\u2019s algorithm",permalink:"/algorithms/shortest-path/dijkstra"}},l=[{value:"How does it work?",id:"how-does-it-work",children:[]},{value:"Practical applications",id:"practical-applications",children:[]},{value:"Shortest path algorithms in NetworkX",id:"shortest-path-algorithms-in-networkx",children:[]},{value:"Where to next?",id:"where-to-next",children:[]}],h={toc:l};function c(t){var e=t.components,s=Object(n.a)(t,["components"]);return Object(o.b)("wrapper",Object(a.a)({},h,s,{components:e,mdxType:"MDXLayout"}),Object(o.b)("p",null,"When planning a road trip, we are trying to minimize our costs in many different areas - gas, time, overnight stays, traffic costs, etc. Calculating these costs can take a lot of effort and time, but what if there was a more elegant way that could solve the problem for you? "),Object(o.b)("p",null,"Pathfinding algorithms are one of the classical graph problems and have been researched since the 19th century. The Shortest Path algorithm is an algorithm that calculates a path between two nodes in a weighted graph such as the sum of the values on the edges that form a path is minimized. "),Object(o.b)("h2",{id:"how-does-it-work"},"How does it work?"),Object(o.b)("p",null,"Starting from the source node, the algorithm looks up the weights on the (out-)going (in weighted graphs) edges. It chooses the edge which, summed to the previous total sum, gives the lowest result. The algorithm runs through every node up until the destination point. Results are a path and the total sum of the shortest path."),Object(o.b)("p",null,Object(o.b)("img",{alt:"Shortest path example",src:r(151).default})),Object(o.b)("h2",{id:"practical-applications"},"Practical applications"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"We use Dijkstra\u2019s algorithm in digital mapping services in Google Maps. Each time we look for directions, we get the time to travel alongside the optimal route. Both of that information are results of Dijkstra\u2019s algorithm. "),Object(o.b)("li",{parentName:"ul"},"While using social networks, you might see suggestions such as \u2018People you might know\u2019 or \u2018People your friends follow\u2019. If the social graph is really small, you can use Dijkstra\u2019s algorithm to find the shortest path between users measuring connections among them."),Object(o.b)("li",{parentName:"ul"},"In telecommunications, each line has a bandwidth, a measure that tells us how much data can go through the line. We can use Dijkstra\u2019s algorithm to determine the shortest paths between sending and receiving points in the network when transmitting data, for example sending an email to all of your friends.")),Object(o.b)("h2",{id:"shortest-path-algorithms-in-networkx"},"Shortest path algorithms in NetworkX"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",{parentName:"tr",align:null},"Name"),Object(o.b)("th",{parentName:"tr",align:null},"Description"),Object(o.b)("th",{parentName:"tr",align:null},"Link"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"Dijkstra\u2019s algorithm"),Object(o.b)("td",{parentName:"tr",align:null},"Finds the shortest path from a source node to the target node if the weights on the edges are non-negative values."),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("a",{parentName:"td",href:"https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.generic.shortest_path.html#networkx.algorithms.shortest_paths.generic.shortest_path"},"NetworkX Reference Guide"))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"Bellman-Ford algorithm"),Object(o.b)("td",{parentName:"tr",align:null},"Find the shortest path from a source node to the target node when edge weights may be negative."),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("a",{parentName:"td",href:"https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.generic.shortest_path.html#networkx.algorithms.shortest_paths.generic.shortest_path"},"NetworkX Reference Guide"))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"A* search algorithm"),Object(o.b)("td",{parentName:"tr",align:null},"Finds the shortest path between the pair of nodes using heuristic methods."),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("a",{parentName:"td",href:"https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.astar.astar_path.html#networkx.algorithms.shortest_paths.astar.astar_path"},"NetworkX Reference Guide"))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"Floyd-Warshall algorithm"),Object(o.b)("td",{parentName:"tr",align:null},"Finds all shortest paths between every pair of nodes in a graph."),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("a",{parentName:"td",href:"https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.dense.floyd_warshall.html#networkx.algorithms.shortest_paths.dense.floyd_warshall"},"NetworkX Reference Guide"))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"Johnson\u2019s algorithm"),Object(o.b)("td",{parentName:"tr",align:null},"Finds all shortest paths between every pair of nodes in a directed graph combining Dijkstra\u2019s and Bellman-Ford\u2019s algorithms."),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("a",{parentName:"td",href:"https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.johnson.html#networkx.algorithms.shortest_paths.weighted.johnson"},"NetworkX Reference Guide"))))),Object(o.b)("h2",{id:"where-to-next"},"Where to next?"),Object(o.b)("p",null,"So far, we have covered these algorithms:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"/algorithms/shortest-path/dijkstra"},"Dijkstra\u2019s algorithm"),","),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"/algorithms/shortest-path/a-star-search"},"A* search algorithm"),","),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"/algorithms/shortest-path/floyd-warshall"},"Floyd-Warshall algorithm"),".")))}c.isMDXComponent=!0},95:function(t,e,r){"use strict";r.d(e,"a",(function(){return p})),r.d(e,"b",(function(){return u}));var a=r(0),n=r.n(a);function o(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function s(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,a)}return r}function i(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?s(Object(r),!0).forEach((function(e){o(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function l(t,e){if(null==t)return{};var r,a,n=function(t,e){if(null==t)return{};var r,a,n={},o=Object.keys(t);for(a=0;a<o.length;a++)r=o[a],e.indexOf(r)>=0||(n[r]=t[r]);return n}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)r=o[a],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(n[r]=t[r])}return n}var h=n.a.createContext({}),c=function(t){var e=n.a.useContext(h),r=e;return t&&(r="function"==typeof t?t(e):i(i({},e),t)),r},p=function(t){var e=c(t.components);return n.a.createElement(h.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.a.createElement(n.a.Fragment,{},e)}},d=n.a.forwardRef((function(t,e){var r=t.components,a=t.mdxType,o=t.originalType,s=t.parentName,h=l(t,["components","mdxType","originalType","parentName"]),p=c(r),d=a,u=p["".concat(s,".").concat(d)]||p[d]||m[d]||o;return r?n.a.createElement(u,i(i({ref:e},h),{},{components:r})):n.a.createElement(u,i({ref:e},h))}));function u(t,e){var r=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var o=r.length,s=new Array(o);s[0]=d;var i={};for(var l in e)hasOwnProperty.call(e,l)&&(i[l]=e[l]);i.originalType=t,i.mdxType="string"==typeof t?t:a,s[1]=i;for(var h=2;h<o;h++)s[h]=r[h];return n.a.createElement.apply(null,s)}return n.a.createElement.apply(null,r)}d.displayName="MDXCreateElement"}}]);